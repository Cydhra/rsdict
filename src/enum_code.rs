use super::constants::SMALL_BLOCK_SIZE;
use std::cmp;

mod binomial {
    // Load in the generated binomial coefficient table generated by `build.rs`.
    include!(concat!(env!("OUT_DIR"), "/binomial.rs"));
}

fn binomial_coefficient(n: u8, k: u8) -> u64 {
    use self::binomial::COEFFICIENT_TABLE;
    debug_assert!(n <= 64 && k <= 64);
    debug_assert!(k <= n);

    // See `build.rs` for an explanation of how the table is indexed.
    let (q, r) = (n as usize / 2, n as usize % 2);
    let row_start = (q + r) * (q + 1);
    let k = cmp::min(k, n - k) as usize;
    COEFFICIENT_TABLE[row_start + k]
}

// Let's say we're coding a bitstring of `n` bits, where `k` of them are set. There are `n` choose
// `k` different bitstrings of this form, so we'd like to map our bitstring to an integer in the
// range
//
//    [0, binomial_coefficient(n, k)).
//
// If `n == k == 0`, then `binomial_coefficient(0, 0) = 1`, so we must return zero as our coded
// value. Let's assume that `n > 0`, so the bitstring in nonempty with a first "head" bits and
// the remaining `n - 1` tail bits. Compute our code inductively on the tail bits. We'd like to
// transform this coded value in some way to be able to also recover the head bit when decoding.
//
// If `n == k` or `k == 0`, the bitstring must be all ones or zeros, respectively. So, we know
// upfront what the head bit must be, so we don't need to emit any new information, and we can
// return the tail's coded value.
//
// If `0 < k < n`, the head bit may either be zero or one. If it's zero, the range of the coded
// tail is `[0, binomial_coefficient(n - 1, k))`, since there are `k` bits in the tail. If the
// head bit is set, the tail's range is `[0, binomial_coefficient(n - 1, k - 1))`. We can code
// our head bit by gluing these two ranges together, creating a final value in
// `[0, binomial_coefficient(n - 1, k) + binomial_coefficient(n - 1, k - 1))`.
//
//
//     [ binomial_coefficient(n - 1, k) ][ binomial_coefficient(n - 1, k - 1) ]
//              head bit is zero         ^         head bit is one
//                                 zero_case_count
//
// Then, `zero_case_count` indicates the start of the region where the head bit is one or,
// alternatively, the number of different tail bitstrings where the head bit is zero. If `n == k`,
// `zero_case_count` must be zero since it's impossible for the first bit to be zero.
//
fn zero_case_count(n: u8, k: u8) -> u64 {
    if n == k {
        0
    } else {
        binomial_coefficient(n - 1, k)
    }
}

pub fn encode(value: u64, class: u8) -> (u8, u64) {
    debug_assert_eq!(value.count_ones() as u8, class);
    let code_len = ENUM_CODE_LENGTH[class as usize];

    // Fast path: return the integer unchanged if we're using all of our bits.
    if code_len == SMALL_BLOCK_SIZE as u8 {
        return (code_len, value);
    }

    let mut code = 0u64;
    let mut k = class;
    for i in 0..(SMALL_BLOCK_SIZE as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        if (value >> i) & 1 != 0 {
            code += zero_case_count(n, k);
            k -= 1;
        }
    }
    (code_len, code)
}

#[cfg(test)]
pub fn decode(mut code: u64, class: u8) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return code;
    }
    let mut value = 0u64;
    let mut k = class;
    for i in 0..(SMALL_BLOCK_SIZE as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        let z = zero_case_count(n, k);
        if code >= z {
            value |= 1 << i;
            code -= z;
            k -= 1;
        }
    }
    value
}

pub fn decode_bit(mut code: u64, class: u8, pos: u64) -> bool {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return (code >> pos) & 1 != 0;
    }
    let mut k = class;
    for i in 0..(pos as u8) {
        let n = SMALL_BLOCK_SIZE as u8 - i;
        let z = zero_case_count(n, k);
        if code >= z {
            code -= z;
            k -= 1;
        }
    }

    let n = SMALL_BLOCK_SIZE - pos;
    code >= zero_case_count(n as u8, k)
}

#[inline(always)]
fn rank_impl(mut code: u64, class: u8, pos: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return (code & ((1 << pos) - 1)).count_ones() as u64;
    }
    let mut cur_rank = class;
    for i in 0..pos {
        let n = SMALL_BLOCK_SIZE - i;
        let z = zero_case_count(n as u8, cur_rank);
        if code >= z {
            code -= z;
            cur_rank -= 1;
        }
    }
    (class - cur_rank) as u64
}

#[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
#[target_feature(enable = "popcnt")]
unsafe fn rank_with_popcount(code: u64, class: u8, pos: u64) -> u64 {
    rank_impl(code, class, pos)
}

pub fn rank(code: u64, class: u8, pos: u64) -> u64 {
    #[cfg(any(target_arch = "x86", target_arch = "x86_64"))]
    {
        if is_x86_feature_detected!("popcnt") {
            return unsafe { rank_with_popcount(code, class, pos) };
        }
    }
    rank_impl(code, class, pos)
}

// Adapted from https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/
pub fn select1_raw(mut code: u64, mut rank: u64) -> u64 {
    debug_assert!(rank < code.count_ones() as u64);
    for _ in 0..64 {
        let t = code & code.wrapping_neg();
        if rank == 0 {
            return code.trailing_zeros() as u64;
        }
        rank -= 1;
        code ^= t;
    }
    debug_assert!(false, "select1_raw past end of codeword");
    0
}

pub fn select1(mut code: u64, class: u8, mut rank: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return select1_raw(code, rank);
    }
    let mut k = class;
    for i in 0..SMALL_BLOCK_SIZE {
        let n = SMALL_BLOCK_SIZE - i;
        let z = zero_case_count(n as u8, k as u8);
        if code >= z {
            if rank == 0 {
                return i;
            }
            rank -= 1;
            code -= z;
            k -= 1;
        }
    }
    debug_assert!(false, "select1 past end of codeword");
    0
}

pub fn select0(mut code: u64, class: u8, mut rank: u64) -> u64 {
    if ENUM_CODE_LENGTH[class as usize] == SMALL_BLOCK_SIZE as u8 {
        return select1_raw(!code, rank);
    }
    let mut k = class as usize;
    for i in 0..SMALL_BLOCK_SIZE {
        let n = SMALL_BLOCK_SIZE - i;
        let z = zero_case_count(n as u8, k as u8);
        if code >= z {
            code -= z;
            k -= 1;
        } else {
            if rank == 0 {
                return i;
            }
            rank -= 1;
        }
    }
    debug_assert!(false, "select0 past end of codeword");
    0
}

#[cfg(test)]
mod tests {
    use super::{binomial_coefficient, decode, decode_bit, encode, rank, select0, select1};
    use crate::test_helpers::hash_u64;
    use std::collections::HashMap;
    use succinct::broadword;

    fn check_value(value: u64) -> bool {
        let class = value.count_ones() as u8;
        let (_, code) = encode(value, class);

        let decoded = decode(code, class) == value;
        let decode_bit = (0..64).all(|i| {
            let computed = decode_bit(code, class, i);
            let expected = (value >> i) & 1 != 0;
            computed == expected
        });
        let rank = (0..64).all(|i| {
            let computed = rank(code, class, i);
            let expected = (value & ((1 << i) - 1)).count_ones() as u64;
            computed == expected
        });
        let select0 = (0..(64 - class) as u64).all(|i| {
            let computed = select0(code, class, i) as usize;
            let expected = broadword::select1_raw(i as usize, !value);
            computed == expected
        });
        let select1 = (0..class as u64).all(|i| {
            let computed = select1(code, class, i) as usize;
            let expected = broadword::select1_raw(i as usize, value);
            computed == expected
        });

        decoded && decode_bit && rank && select0 && select1
    }

    #[test]
    fn test_enum_code() {
        for i in 0..64 {
            assert!(check_value(std::u64::MAX << i));
        }
        assert!(check_value(0));
    }

    #[quickcheck]
    fn qc_enum_code(value: u64) -> bool {
        check_value(value)
    }

    #[quickcheck]
    fn qc_enum_code_hashed(value: u64) -> bool {
        check_value(hash_u64(value))
    }

    #[test]
    fn test_binomial_coefficient_table() {
        fn lookup(table: &mut HashMap<(u8, u8), u64>, n: u8, k: u8) -> u64 {
            if k == 0 || k == n {
                return 1;
            }
            if let Some(&v) = table.get(&(n, k)) {
                return v;
            }
            let v = lookup(table, n - 1, k - 1) + lookup(table, n - 1, k);
            table.insert((n, k), v);
            v
        }
        let mut table = HashMap::new();
        for n in 0..=64 {
            for k in 0..=n {
                assert_eq!(binomial_coefficient(n, k), lookup(&mut table, n, k));
            }
        }
    }
}

// Precomputed number of bits it takes to represent a block of 64 bits where k
// of them are set: ceil(log(binomial_coefficient(64, k))) for k in [0, 64].
// However, note that once the code length is sufficiently long (> 46), we just
// set it to 64 to hit the fast paths above.  It's not worth using a variable
// length code to save a few bits when it makes computing `rank` and `select`
// much more expensive.
pub const ENUM_CODE_LENGTH: &[u8; 65] = &[
    0, 6, 11, 16, 20, 23, 27, 30, 33, 35, 38, 40, 42, 44, 46, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
    64, 64, 46, 44, 42, 40, 38, 35, 33, 30, 27, 23, 20, 16, 11, 6, 0,
];
